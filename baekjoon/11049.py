from sys import stdin


def sol():

    N = int(stdin.readline())

    # 행렬 순서는 바꾸지 않고
    # 곱셈 순서만 바꾸자

    # 결국에 곱하는 순서에서 최적을 찾아야함

    # N<=500

    # 그러면 이렇게 생각해야됨.
    # 내가 이번 행렬을 계산할때
    # 연기할수도있음 나중에 곱하려고
    # vs 지금 당장 곱하는 선택지 어느게 더적을까?

    # 예를 들어, A의 크기가 5×3이고, B의 크기가 3×2, C의 크기가 2×6인 경우에 행렬의 곱 ABC를 구하는 경우를 생각해보자.

    # AB를 먼저 곱하고 C를 곱하는 경우 (AB)C에 필요한 곱셈 연산의 수는 5×3×2 + 5×2×6 = 30 + 60 = 90번이다.
    # BC를 먼저 곱하고 A를 곱하는 경우 A(BC)에 필요한 곱셈 연산의 수는 3×2×6 + 5×3×6 = 36 + 90 = 126번이다.

    # 결국 괄호 어떻게 치는지 계산하는거같은데
    # 행렬의 곱이 최소가 되려면
    # 어떤 구간에서 [a,b] 에서 곱할때
    # 이걸 분할해서 생각해야됨 왜냐면 무조건 모든 경우에서 곱셈을 할 수 있으니까

    # [1,4]에서 보자
    # 그럼 1 * [2,4]의 결과물
    # 혹은 [1,3] * 4 의 결과물
    # 1 * [2,3] * 4 -> [1,3] * 4 에 포함된다

    # 그럼 [1,4] 는 1*[2,4] or [1,3] * 4  or [1,2] * [3*4] ...
    # 그럼 이렇게도 표현할수 있음
    # 1(2~4) or (1~3)4 or ((1,2)(3,4))
    # 그럼 1*[2,4] 구간 최솟값 + 합치기 비용
    # [1,3] 구간 최솟값 + 4와의 합치기비용
    # [1,2] 구간 최솟값 + [3,4] 구간 최솟값 + 합치기 비용

    # 근데 합치기 비용은 맨앞 r , 가운데꺼 c 혹은 가운데+1꺼 r , 마지막꺼 c 다 곱한것임

    # 결국에 어디까지 먼저 계산할거냐니까
    # 딱 구간나눠서 생각할 수 있다는거임

    # [a,b]가 있다고 해보자.
    # 그럼 [a,X] [X,Y] [Y,b]로 분할할 수 있는거아님?
    # 이때 a<=X<Y<=b 인상태임
    # 등호가 포함된 이유는 a 혹은 b가 가장 마지막에 계산될때

    # d[a,b]= min (d[a,X]+d[X+1,b]+합치기비용) 일때 X와 Y는 움직임

    # d[1,4] = min(d[1,1]+d[2,4], d[1,2]+d[3,4], d[1,3]+d[4,4])
    #               1*(2~4)         (1~2)(3~4)     (1~3)4
    matrix = []
    for _ in range(N):
        r, c = map(int, stdin.readline().split())
        matrix.append((r, c))

    dp = [[98765432109876543210 for _ in range(N)] for _ in range(N)]

    def calc(i, j, d):
        if d[i][j] != 98765432109876543210:
            return d[i][j]
        if i == j:
            d[i][i] = 0
            return 0
        if i + 1 == j:
            d[i][j] = matrix[i][0] * matrix[j][0] * matrix[j][1]
            return d[i][j]
        else:
            for k in range(i, j):
                d[i][j] = min(
                    d[i][j],
                    calc(i, k, d)
                    + calc(k + 1, j, d)
                    + matrix[i][0] * matrix[k + 1][0] * matrix[j][1],
                )
            return d[i][j]

    calc(0, N - 1, dp)

    return dp[0][N - 1]


print(sol())
